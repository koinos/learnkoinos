# Smart Contract Tutorial

In this tutorial we will create a smart contract that stores and retrieves todo items on the Koinos blockchain. Please note: this is only for demonstration it is not a practical application for a smart contract. This will help us understand how Protocol Buffers work as well as how to define and store state on the blockchain.

This is part 2 of a 4 part series on how to develop smart contracts on the Koinos blockchain. Part 1 on setting up the dev environment can be found [here](https://learnkoinos.xyz/docs/modules/M4/1_introduction.html).

## Todo list

Understanding Protocol Buffers in Koinos Smart Contracts

From Google:

> Protocol buffers are Googleâ€™s language-neutral, platform-neutral, extensible mechanism for serializing structured data â€“ think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.

On Koinos, Protocol buffers help our smart contracts to communicate with the outside world. A function that has to interact with an api call or execute database read/write must first pipe the data structure through PB in order to facilitate seamless communication.

![PB.png](/img/pb.png)


For this demonstration we will use a todo list as a way to learn how to create a smart contract that stores and retrieves data from the blockchain. This is not a practical decentralized application (dApp) but we will learn basic functionality that is necessary for smart contract development.

Letâ€™s generate `todos` by running the command `koinos-sdk-as-cli create todos`

We can now cd into our new `todos` directory and install the necessary dependencies by running `yarn`

Just to be sure everything is working correctly letâ€™s build the contract and run the `test` command.

`yarn build:debug`

`yarn test`

**Goal:**

Create a smart contract that accepts a todo item, writes it to the blockchain and then be able to read a list of all todos from the blockchain.

We will need two functions:

1. Add a todo and store it in chain state
2. Get all of the todos from chain state

The first thing we will need to do is to define the data in the `todos.proto` file.

`todos.proto`

```jsx
syntax = "proto3";

package todos;

// @description Add todo to the todo list
// @read-only false
message add_todo_arguments {
  string task = 1;
}

message add_todo_result {}

// @description Returns the list of todos
// @read-only true
message get_todos_arguments {}

message get_todos_result {
  repeated string value = 1;
}

// @description The object keeing track of todos in chain state
message todo_object {
  repeated string tasks = 1;
}
```

Once we define our proto file we can generate the boilerplate code by running the command: `yarn build:debug`

We will see the following error:

```jsx
ERROR TS2339: Property 'add_todo' does not exist on type 'assembly/Todos/Todos'.

       const res = c.add_todo(args);

....
```

This is expected behavior as we have not yet written our Todos.ts file

Open `Todos.boilerplate.ts` we will need to copy the code here and paste it into our Todos.ts file. Here we will write out our functions to write a todo to the chain and then retrieve the todos from the chain.

But first, letâ€™s create the state files and add a storage constructor.

In the `assembly` directory of our project letâ€™s create a directory called `state`

Here we will add two files `SpaceIds.ts` and `TodoStorage.ts`

`./state/SpaceIds.ts`

```jsx
export const TODOS_SPACE_ID = 0
```

Here we define the id of the space for our storage.

SpaceIds are a convenient way to identify different tables within our database array. This helps us during data retrieval because we can easily expect the type of data stored in each table. TheÂ `SpaceId.ts`Â file should have at a minimum the first line shown above, however we may use as many Space IDs as we need for our project. The numbered values represent the id of the storage space and can be any value we wish.

`./assembly/state/TodoStorage.ts`

```jsx
import { Storage } from "@koinos/sdk-as"
import { todos } from "../proto/todos"
import { TODOS_SPACE_ID } from "./SpaceIds"

export class TodoStorage extends Storage.Obj<todos.todo_object> {
  constructor(contractId: Uint8Array) {
    super(
      contractId,
      TODOS_SPACE_ID,
      todos.todo_object.decode,
      todos.todo_object.encode,
      () => new todos.todo_object()
    )
  }
}
```

Here we are creating a constructor to define the encoding and decoding of the todos object.

We can now move on to the Todos.ts file and add our functions.

`./assembly/Todos.ts`

```jsx
import { System, authority } from "@koinos/sdk-as";
import { todos } from "./proto/todos";
import { TodoStorage } from "./state/TodoStorage";

export class Todos {
  // Gets the contract ID from the system and stores it in a private variable
  _contractId: Uint8Array = System.getContractId();
  // Creates a new instance of the TodoStorage class
  _todoStorage: TodoStorage = new TodoStorage(this._contractId);

  // Adds a todo and stores it to chain state
  // Since this is a write operation, it must be called within a transaction
  add_todo(args: todos.add_todo_arguments): todos.add_todo_result {

    // retrieves the todo object from chain state
    let todosObj = this._todoStorage.get();

    // if the todo object does not exist, create a new one
    if (!todosObj) {
      todosObj = new todos.todo_object();
    }

    // add the new task to the todo object
    todosObj.tasks.push(args.task!);

    // store the todo object to chain state
    this._todoStorage.put(todosObj);

    // create an empty result because we don't need to return anything
    return new todos.add_todo_result();

  }

  // Gets all todos from chain state
  // Because this is a read operation, it does not need to be called within a transaction
  get_todos(args: todos.get_todos_arguments): todos.get_todos_result {
    // retrieves the todo object from chain state
    let todosObj = this._todoStorage.get();

    // if the todo object does not exist, create a new one
    if (!todosObj) {
      todosObj = new todos.todo_object();
    }

    // create a new result object and set the value to the tasks from the todo object
    const res = new todos.get_todos_result();

    // set the value of the result object to the tasks from the todo object
    res.value = todosObj.tasks;

    return res;
  }
}
```

We first import TodoStorage from our `TodoStorage.ts` file.

We then export a class called `Todos` which contains the two functions we will need in order to achieve our goal.

We first need to instantiate variables to hold the `contractId` from the system as well as the `TodoStorage` constructor from the state file we created earlier.

**First function: `add_todo`**

In the add to do function we first add the argument we defined in our proto file as well as the result.

```jsx
 add_todo(args: **todos.add_todo_arguments**): **todos.add_todo_result** {
	...
```

We then retrieves the todo object from chain state, if the todo object does not exist, create a new one. We can then add the new task to the todo object and finally store the todo object to chain state. We create an empty result because we don't need to return anything.

```jsx
    // retrieves the todo object from chain state
    let todosObj = this._todoStorage.get();

    // if the todo object does not exist, create a new one
    if (!todosObj) {
      todosObj = new todos.todo_object();
    }

    // add the new task to the todo object
    todosObj.tasks.push(args.task!);

    // store the todo object to chain state
    this._todoStorage.put(todosObj);

    // create an empty result because we don't need to return anything
    return new todos.add_todo_result();
```

**Second function: `get_todos`**

Because this is a read operation, it does not need to be called within a transaction. We first retrieve the todo object from chain state, if the todo object does not exist, we create a new one. We can then create a new result object and set the value to the tasks from the todo object. And finally set the value of the result object to the tasks from the todo object.

```jsx
  // Because this is a read operation, it does not need to be called within a transaction
  get_todos(args: todos.get_todos_arguments): todos.get_todos_result {
    // retrieves the todo object from chain state
    let todosObj = this._todoStorage.get();

    // if the todo object does not exist, create a new one
    if (!todosObj) {
      todosObj = new todos.todo_object();
    }

    // create a new result object and set the value to the tasks from the todo object
    const res = new todos.get_todos_result();

    // set the value of the result object to the tasks from the todo object
    res.value = todosObj.tasks;

    return res;
  }
```

We are now ready to build our contract by running the command `yarn build:release`

If there are no errors we can upload the `contract.wasm` file and `todos.abi` to the Koinos testnet.

Letâ€™s fire up our Koinos CLI and open the testnet wallet, remember that we need to have some tKOIN in order to upload the contract. (if you havenâ€™t set one up yet, take a look at this tutorial [https://learnkoinos.xyz/docs/modules/M1/1_introduction.html](https://learnkoinos.xyz/docs/modules/M1/1_introduction.html))

Once we have the wallet open we can issue the following command:

`upload todos/build/release/contract.wasm todos/abi/todos.abi`

The result should look something like this:

```jsx
Contract uploaded with address 1GB8ZYZNvz6efGRKdiCYtk23Pk6yLREZCu
Transaction with ID 0x122033a6fe5457fc1f3f8287943924909290f51be09e270187c0552dadf44b78d630 containing 1 operations submitted.
Mana cost: 0.30183113 (Disk: 3955, Network: 19687, Compute: 350618)
```

Our contract is now live on the Koinos network.

Letâ€™s test it out!

We first need to register the contract by issuing the command `register todos 1GB8ZYZNvz6efGRKdiCYtk23Pk6yLREZCu`

Now we have access to the functions in the contract. Letâ€™s add a todo item to the list.

`todo.add_todo "Write a todo list smart contract"`

The response should look something like this:

```jsx
Calling todos.add_todo with arguments 'task: "Write a todo list smart contract"
'
Transaction with ID 0x12201c928be40d6bbd221a487fd9cd6af900172447e7378b40b29ea8927684388689 containing 1 operations submitted.
Mana cost: 0.01771484 (Disk: 50, Network: 274, Compute: 347897)
```

We can now call the `todos.get_todos` function which should return the following:

```jsx
value: "Write a todo list smart contract"
```

**Conclusion**

We were able to successfully write a smart contract that can write data to the blockchain as well as retrieve that data. In the process we learned how to use Protocol Buffers on the Koinos blockchain as well as how to define our state and storage space.

In the next installment we will create a simple front end that can communicate with our todos smart contract so we can write and read date from a web page.

## Front End

# Todo List Front End

In this tutorial we will build on our previous tutorial in which we created a todo list smart contract. Our goal is to build a front end that can be deployed to a web server to allow users to interact with our smart contract through a GUI.

This is part 3 of a 4 part series on how to develop smart contracts on the Koinos blockchain.

- Part 1 on setting up the dev environment can be found [here](https://learnkoinos.xyz/docs/modules/M4/1_introduction.html).
- Part 2 on building the smart contract can be found [here](https://learnkoinos.xyz/docs/modules/M8/1_todos.html).

We will use HTML, CSS and vanilla JS but you can use Vue, React, Svelte etc. Itâ€™s also possible to connect to the smart contract using Swift or Kotlin on mobile. In this tutorial we are using the Kondor wallet Chrome extension, we can also use [WalletConnect](https://www.npmjs.com/package/@armana/walletconnect-koinos-sdk-js) but that is out of the scope of this exercise. We will need a test account in Kondor with some tKoin.

The code can be found here [https://github.com/koinos/todos-front-end](https://github.com/koinos/todos-front-end)

We will only need two files plus the libraries to make this work and the second one is optional. If we wanted to we could contain the entire app in one HTML file.

Files:

`index.html`

`style.js`

Dependencies:

`kondor.js`

`koinos.js`

### Basic Structure

We first need to create the basic HTML structure. These are the elements we will need:

- A button to connect to Kondor
- An input to enter the todo
- A button to submit the todo to the blockchain (execute the `addTodo` function)
- A div to hold the response from the blockchain
- A button to retrieve the current list of todos from the blockchain (execute the `getTodos` function)
- A div to display the payload returned from the blockchain

Here is an image of the finished product

![final-design](/img/final-design.png)

Basic HTML code:

```html
<div id="app">
  <header>
    <button
      id="getAccounts"
      class="secondary-button"
    >
      Connect kondor
    </button>
    <h1>Koinos Todos</h1>
    <input
      type="text"
      placeholder="What needs to be done?"
      id="newTodo"
    />
    <button id="addTodo">Submit</button>
    <div id="minde-block"></div>
  </header>
  <div class="loader-container">
    <span
      id="loader"
      class="loader invisible"
    ></span>
  </div>
  <div class="card">
    <div
      class="results"
      id="display-results"
    ></div>
    <button id="getTodos">Get Todos</button>
  </div>
</div>
```

The CSS code is at the end of this tutorial, the styling is completely optional.

Next we will need to add the libraries necessary to make the connection to our smart contract:`kondor.js` and `koinos.js`

```html
<script src="js/kondor.js"></script>
<script src="js/koinos.js"></script>
```

### Kondor Wallet

The `kondor.js` library allows us to interact with the Kondor wallet. We will use the Kondor wallet to pay the Mana necessary to execute transactions on the blockchain. You can install the Kondor Chrome extension [here](https://chrome.google.com/webstore/detail/kondor/ghipkefkpgkladckmlmdnadmcchefhjl).

Letâ€™s dive into the JavaScript code. To make things super simple we will put the JS directly into our HTML file right before the closing `</body>` tag.

```jsx
<script type="module">
        // declare contract and accounts variables
        let todosContract;
        let accounts;

        // Connect to kondor
        async function connectKondor() {
            console.log("Connecting kondor...")
            accounts = await kondor.getAccounts();
            console.log("Kondor connected");
            console.log(accounts);
        }

        // Get the contract from the blockchain
        async function getContract() {
            if (todosContract) return todosContract;
            if (!accounts) await connectKondor();
            const provider = new Provider(["https://harbinger-api.koinos.io"]);
            const userAddress = accounts[0].address;
            const todosContractAddress = "1BKnB35ow1rhJ5WJUmYTBdkfSTBPbyqrQg";

            todosContract = new Contract({
                id: todosContractAddress,
                provider,
                signer: kondor.getSigner(userAddress),
            });

            // get the abi of todosContract
            await todosContract.fetchAbi();

            // update abi to be compatible with koilib
            todosContract.abi.methods.add_todo.entry_point = Number(todosContract.abi.methods.add_todo["entry-point"]);
            todosContract.abi.methods.add_todo.read_only = todosContract.abi.methods.add_todo["read-only"];
            todosContract.abi.methods.get_todos.entry_point = Number(todosContract.abi.methods.get_todos["entry-point"]);
            todosContract.abi.methods.get_todos.read_only = todosContract.abi.methods.get_todos["read-only"];

            return todosContract;
        }

        // Get the list of todos from the blockchain
        async function getTodos() {
            const contract = await getContract();
            const { result } = await contract.functions.get_todos();
            document.getElementById("display-results").innerHTML = JSON.stringify(result.value);
        }

        // Call the add_todo function on the contract
        async function addTodo() {
            const { value: task } = document.getElementById("newTodo");
            const contract = await getContract();
            const { transaction, receipt } = await contract.functions.add_todo({ task });
            console.log("submitted. Receipt:");
            console.log(receipt);

            // wait to be mined
            const { blockNumber } = await transaction.wait();
            console.log(`mined in block ${blockNumber}`);
            document.getElementById("minde-block").innerHTML = `mined in block ${blockNumber}`;
        }

        document.getElementById("getAccounts").addEventListener("click", connectKondor);
        document.getElementById("addTodo").addEventListener("click", addTodo);
        document.getElementById("getTodos").addEventListener("click", getTodos);
</script>
```

Letâ€™s break down the code above.

We first declare the `todosContract` and `accounts` variables and then create an asynchronous function to connect to the Kondor wallet.

```jsx
// declare contract and accounts variables
let todosContract;
let accounts;

// Connect to kondor
async function connectKondor() {
  console.log("Connecting kondor...");
  accounts = await kondor.getAccounts();
  console.log("Kondor connected");
  console.log(accounts);
}
```

Next we create another asynchronous function which connects to our smart contract on the blockchain.

```jsx
// Get the contract from the blockchain
async function getContract() {
  if (todosContract) return todosContract;
  if (!accounts) await connectKondor();
  const provider = new Provider(["https://harbinger-api.koinos.io"]);
  const userAddress = accounts[0].address;
  const todosContractAddress = "1BKnB35ow1rhJ5WJUmYTBdkfSTBPbyqrQg";

  todosContract = new Contract({
    id: todosContractAddress,
    provider,
    signer: kondor.getSigner(userAddress),
  });

  // get the abi of todosContract
  await todosContract.fetchAbi();

  // update abi to be compatible with koilib
  todosContract.abi.methods.add_todo.entry_point = Number(
    todosContract.abi.methods.add_todo["entry-point"]
  );
  todosContract.abi.methods.add_todo.read_only =
    todosContract.abi.methods.add_todo["read-only"];
  todosContract.abi.methods.get_todos.entry_point = Number(
    todosContract.abi.methods.get_todos["entry-point"]
  );
  todosContract.abi.methods.get_todos.read_only =
    todosContract.abi.methods.get_todos["read-only"];

  return todosContract;
}

// Get the list of todos from the blockchain
async function getTodos() {
  const contract = await getContract();
  const { result } = await contract.functions.get_todos();
  document.getElementById("display-results").innerHTML = JSON.stringify(
    result.value
  );
}
```

All that is left now is to add our `getTodos` and `addTodo` functions

```jsx
// Get the list of todos from the blockchain
async function getTodos() {
  const contract = await getContract();
  const { result } = await contract.functions.get_todos();
  document.getElementById("display-results").innerHTML = JSON.stringify(
    result.value
  );
}

// Call the add_todo function on the contract
async function addTodo() {
  const { value: task } = document.getElementById("newTodo");
  const contract = await getContract();
  const { transaction, receipt } = await contract.functions.add_todo({ task });
  console.log("submitted. Receipt:");
  console.log(receipt);

  // wait to be mined
  const { blockNumber } = await transaction.wait();
  console.log(`mined in block ${blockNumber}`);
  document.getElementById(
    "minde-block"
  ).innerHTML = `mined in block ${blockNumber}`;
}
```

We are now ready to test out our application. Letâ€™s connect to Kondor and now all we have to do is serve our HTML file locally (Iâ€™m using the VSCode Live Server extension). Once connected we can add the text for our todo and click `Submit`. We will be asked to check the events for the smart contract (recommended) and click `Send`Kondor will let us know how much Mana the transaction will cost.

After clicking `Send` we will have to wait a few seconds and if our call was successful we will get a message similar to this:

![display list](/img/display-list.png)

We can now click the `Get Todos` button to see all of the todos in our contract.

![confirmation](/img/confirmation.png)

### Conclusion:

In this tutorial we were able to create a front end and connect it to our smart contract. We used the Kondor wallet and library. We achieved our goal with just one HTML file and two libraries.

The CSS Code:

```css
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
  align-items: flex-start;
  color: white;
  background-color: #242424;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 600px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
  display: flex;
  flex-direction: column;
  height: 100vh;
  justify-content: space-around;
}
#mined-block {
  padding: 1em;
  color: #fcff64;
}

.card {
  padding: 2em;
  margin-bottom: 3em;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #646cff;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #fcff64;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

input {
  border-radius: 8px;
  border: 1px solid #1a1a1a;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  color: #fff;
  transition: border-color 0.25s;
}
#mined-block {
  padding: 0.8em;
  text-transform: uppercase;
  color: #b6b2b2;
  margin-top: 2em;
}
.results {
  margin-top: 2em;
  text-align: left;
  padding: 2em;
}

.invisible {
  visibility: hidden;
}
.visible {
  visibility: visible;
}
.secondary-button {
  background: none;
  text-decoration: underline;
}
.secondary-button:hover {
  color: #646cff;
  border: #213547;
}

.loader {
  width: 48px;
  height: 48px;
  display: inline-block;
  position: relative;
}
.loader::after,
.loader::before {
  content: "";
  box-sizing: border-box;
  width: 48px;
  height: 48px;
  border: 4px solid #fff;
  position: absolute;
  left: 0;
  top: 0;
  animation: animloader 2s ease-in-out infinite;
}
.loader::after {
  border-color: #646cff;
  animation-delay: 1s;
}

@keyframes animloader {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 0;
  }
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
```

## Advanced Concepts

# Todo List Advanced Concepts

In this tutorial, we will look at some advanced topics of Koinos smart contract development, events, authorization, and testing. At the end of this tutorial our todo contract will properly require authorization which will be customized, will emit events to more easily track actions on our contract, and our contract will be properly unit tested.

This is part 4 of a 4 part series on how to develop smart contracts on the Koinos blockchain.

- Part 1 on setting up the dev environment can be found [here](https://learnkoinos.xyz/docs/modules/M4/1_introduction.html).
- Part 2 on building the smart contract can be found [here](https://learnkoinos.xyz/docs/modules/M8/1_todos.html).
- Part 3 on creating a front end to interact with the contract can be found [here](https://learnkoinos.xyz/docs/modules/M8/2_todos_front_end.html).

This tutorial will continue working with the todo smart contract written in part 2.

The code for this tutorial can be found [here](https://github.com/koinos/todos/tree/workshop-4/assembly).

### Authorization

On Koinos, unlike on Ethereum, where contract addresses are separate from user addresses, contracts and users are the same primitive. In other words, contracts are users and users are contracts. This creates unique possibilities on the Koinos blockchain that are not possible on other blockchains. Contracts, by default, are upgradable using the key associated with the contract address. For many contracts, however, this is not a desirable feature. The immutability of a token contract is important to secure user assets.

The Koinos blockchain framework supports a programmable authorization system to allow contracts to define how they are authorized. This can simply cause a contract to be immutable, or define decentralized upgrade semantics. For an address that is intended solely for a user, this enables the creation of smart contract wallets where authorization mechanisms such as hierarchical multisig can be implemented.

Defining custom authorization is simple. All that needs to be done is implement a specific `authorize` function in your smart contract. Using the AS SDK, you can add the `authorize` function by adding `--generate_authorize` to the build commands in `package.json`

```json
  "scripts": {
    "lint": "eslint --max-warnings 0 --ext ts \"*/assembly/**/*.ts\"",
    "build:debug": "koinos-sdk-as-cli build-all --generate_authorize debug 0 todos.proto",
    "build:release": "koinos-sdk-as-cli build-all --generate_authorize release 0 todos.proto",
    "test": "koinos-sdk-as-cli run-tests"
  }
```

The next time you build, the authorize function will be added to the generated `Todos.boilerplate.ts`.

```ts
  authorize(args: authority.authorize_arguments): authority.authorize_result {
    // const call = args.call;
    // const type = args.type;

    // YOUR CODE HERE

    const res = new authority.authorize_result();
    res.value = true;

    return res;
  }
```

Copy the function into `Todos.ts`. We'll implement this in a second.

The other side of authorization is requiring authorization. It is important for contracts to be able to restrict access to the contract. It would be bad for Alice to be able to spend Bob's KOIN. Currently, our Todo contract has no restrictions on it whatsoever. Anyone can add an item to our Todo list. Let's fix that.

```ts
  add_todo(args: todos.add_todo_arguments): todos.add_todo_result {
    // Require this contract's authority to add a todo
    System.requireAuthority(authority.authorization_type.contract_call, System.getContractId());

    ...
  }
```

This system call will call `authorize` on our current contract (returned by `System.getContractId()`) and check for `contract_call` authorization. Let's break this down a little.

When checking authority, a contract can either have `authorize` overridden or not. If it does not the Koinos system checks if the address signed the transaction at all. It may be the only signature on the transaction or one of many. But if the signature is there, the call is authorized. If the address has overridden `authorize`` with a smart contract the system will call in to that function. Whatever the return type is will be the result. That is completely left up to the contract. Likely it will be some form of cryptographic authorization, but it could be anything.

There are three types of authorization, `contract_call`, `transaction_application`, and `contract_upload`. The `call_contract` authorization is what user smart contracts use. This asks the contract if they authorize a call to the current contract. `transaction_application` asks the contract if they authorize the application of the transaction. This is used when an address is listed as the `payer` or `payee` of a transaction and is required to use the address' mana for transaction application. The last authorization type is `contract_upload`. This asks the contract if a new contract can be uploaded at this address. This can be used to make a contract immutable by always returning `false`, or implementing a permissioned upload strategy. You can interact with all three types of authorization when implementing `authorize`, but when requiring authority from a contract, you will only use the `contract_call` authorization type.

This call will check if the current contract has an `authorize` override. If it does not, then the system will check if the transaction is signed by the Todo contract address. If it is, the contract execution will continue. If it does not, then the execution will stop and the transaction will be reverted.

Now we can implement our `authorize` function.

```ts
  authorize(args: authority.authorize_arguments): authority.authorize_result {
    // TODO: Replace base58 decode with array literal
    const otherAddr = Base58.decode('1NRz4i4UhVJ5MMeNwDTwTY95ZygtpuPwPU');
    const contractId = System.getContractId();

    // Transaction signatures sign the transaction id, so we need it to check the signatures against
    const transactionId = System.getTransactionField('id')!.bytes_value!;
    const signatures = Protobuf.decode<value.list_type>(System.getTransactionField('signatures')!.message_value!.value!, value.list_type.decode);

    // For each signature, recover the public key associated with it.
    // Check the address of the public key and if it matches the contract address or the other address, we authorize
    for (let i = 0; i < signatures.values.length; i++) {
      const signature = signatures.values[i].bytes_value!;
      let recoveredKey = System.recoverPublicKey(signature, transactionId)!;
      const addr = Crypto.addressFromPublicKey(recoveredKey);
      if (Arrays.equal(addr, contractId) || Arrays.equal(addr, otherAddr)) {
        return new authority.authorize_result(true);
      }
    }

    // If none of the signatures matched the expected addresses, we fail to authorize
    return new authority.authorize_result(false);
  }
```

You can replace `1NRz4i4UhVJ5MMeNwDTwTY95ZygtpuPwPU` with another address you control if you want to test the authorization function yourself on the testnet.

There is quite of code, but it is not too bad. First, we declare the addresses that we are looking for. For this `authorize` implementation we are going to allow the contract address and a second address, `1NRz4i4UhVJ5MMeNwDTwTY95ZygtpuPwPU`. This would be considered a 1 of 2 multisig. We now have to do a bit of the cryptography ourselves. Thankfully, there are Koinos system calls to handle that for us. We get the transaction id and the transaction signatures using the `getTransactionField` system call. We know ahead of time what types will be returned (`bytes_value` and `list_type`), so we can go ahead and convert those to the correct types.

Then, we iterate through each signature. For each signature, we recover the public key from the signature, convert the public key into an address, and check if the address matches either of our expected addresses. If it does, we return true. If we do not find any of our expected addresses, we return false.

To actually override our `authorize` function, we need to upload the contract with the override option.

```
Koinos CLI v2.0.0
Type "list" for a list of commands, "help <command>" for help on a specific command.
ðŸ” > help upload
Upload a smart contract
Usage: upload <filename:file> [abi-filename:file] [override-authorize-call-contract:bool] [override-authorize-transaction-application:bool] [override-authorize-upload-contract:bool]
```

When uploading a contract, the last four options (ABI, and the three overrides) are optional. If you want to override `authorize`, we recommend explicitly setting each. For the purposes of this tutorial, all we will override is the contract call override.

The command we would use is:

```
ðŸ”“ > upload contract.wasm todos.abi true false false
```

Let's hold off on uploading the contract for now. We will do so at the end of the tutorial.

### Events

The next feature we want to add to our contract is an event. Events are a way for contracts to communicate back outside the blockchain. Events are defined as protobuf messages. Let's add an event for when a task is added to our todo list. In `todos.proto` lets add the following.

```protobuf
// @description Event when a todo is added to the list
message todo_added_event {
  string task = 1;
}
```

The event can be named whatever you want it to be. It does not have any special requirements like function argument and return types, but appending the name with `_event` makes the purpose of the message clear.

Submitting an event is as simple as calling the `event` system call. Add the following to the end of `add_todo`.

```ts
  add_todo(args: todos.add_todo_arguments): todos.add_todo_result {
    ...

    // Create a new event and submit it via the event system call
    let event = new todos.todo_added_event();
    event.task = args.task!;

    System.event('todos.todo_added_event', Protobuf.encode(event, todos.todo_added_event.encode), [System.getContractId()]);

    // create an empty result because we don't need to return anything
    return new todos.add_todo_result();
  }
```

We first create the event and fill out the information. In this case, we want the event to contain the same task as the argument. When we call `System.event`, we pass in three arguments. The first is the name of the event. This can be whatever you want, but is intended to be a machine-readable name. For this reason, we recommend you namespace the event within your contract. The second argument is the serialized protobuf message. The third argument is an array of addresses called the impacted addresses. This is a way for the event to communicate which addresses were affected by the event. For example, for a token transfer event, the `from` and `to` addresses are listed as impacted. For our event, we just list the current contract as the impacted address.

Events are returned on transaction and block receipts and are indexed in the account history microservice. This event is a simple example and a bit redundant because it is identical to the system call, but can be quite useful for communicating side effects of complex contract calls. We will find our event in the account history microservice later in this tutorial.

### Testing

The AS SDK also supports contract testing. When you created your contract some basic test files were created under `assembly\__tests__`. Your tests go under `Todos.spec.ts`. The tests are compiled as Assembly Script and run on your contract directly. To interact with the Koinos system the SDK makes use of a Javascript library called MockVM. MockVM simulates parts of the Koinos system for the purpose of unit testing. It allows complex behaviors of the Koinos system to be fudged for testing. The SDK provides an interface for interacting with MockVM by importing MockVM.

The test structure is straightforward.

```ts
import { Arrays, authority, Base58, MockVM } from "@koinos/sdk-as"
import { Todos } from "../Todos"
import { todos } from "../proto/todos"

const CONTRACT_ID = Base58.decode("1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe")

describe("todos", () => {
  beforeEach(() => {
    MockVM.reset()
    MockVM.setContractId(CONTRACT_ID)
  })

  it("should add todo items", () => {
    const c = new Todos()

    // MockVM mimics the Koinos system. It does not need transaction information to check authorization
    // Instead we set what we want the result of the next to authorizations to be
    let auth = new MockVM.MockAuthority(
      authority.authorization_type.contract_call,
      CONTRACT_ID,
      true
    )
    MockVM.setAuthorities([auth, auth])

    // Check when list is empty
    let res = c.get_todos(new todos.get_todos_arguments())
    expect(res.value.length).toBe(0)

    // Add an item
    const args = new todos.add_todo_arguments("Test item 1")
    c.add_todo(args)

    res = c.get_todos(new todos.get_todos_arguments())
    expect(res.value.length).toBe(1)
    expect(res.value[0]).toBe("Test item 1")

    // Add a second item
    args.task = "Test item 2"
    c.add_todo(args)

    res = c.get_todos(new todos.get_todos_arguments())
    expect(res.value.length).toBe(2)
    expect(res.value[0]).toBe("Test item 1")
    expect(res.value[1]).toBe("Test item 2")

    // Check events
    let events = MockVM.getEvents()
    expect(events.length).toBe(2)
    expect(events[0].name).toBe("todos.todo_added_event")
    expect(events[0].impacted.length).toBe(1)
    expect(Arrays.equal(events[0].impacted[0], CONTRACT_ID)).toBe(true)
    expect(events[1].impacted.length).toBe(1)
    expect(Arrays.equal(events[1].impacted[0], CONTRACT_ID)).toBe(true)
  })

  it("should not add todo item without authorization", () => {
    const c = new Todos()

    // Check the contract throws when adding a todo is not authorized
    // NOTE: We did not call MockVM.setAuthorities.
    // We could also have given it an authority that would return false
    expect(() => {
      // AS does not yet support lambda captures, so all variables must be defined within the lambda
      const c = new Todos()
      const args = new todos.add_todo_arguments("Test item 1")
      c.add_todo(args)
    }).toThrow()

    // Check there were no side effects of the call
    let res = c.get_todos(new todos.get_todos_arguments())
    expect(res.value.length).toBe(0)

    let events = MockVM.getEvents()
    expect(events.length).toBe(0)
  })

  it("should authorize", () => {
    // TODO: MockVM does not yet support required system calls to test authorize function
  })

  it("should not authorize", () => {
    // TODO: MockVM does not yet support required system calls to test authorize function
  })
})
```

There are a few things that should be pointed out that can be tricky. When setting authorities on MockVM, the authorities are consumed on `authorize` calls. Because our test calls `add_todo` twice and we want them both to succeed, we add the authority to MockVM twice.

The second trap is that Assembly Script does not yet support variable captures in lambda functions. So in our second test when we want to check that `add_todo` throws when not authorized, we have to redeclare the contract within the lambda. This shouldn't cause a problem because your contract class should not rely on any persistent in memory state (all persisence must be through the Koinos database layer).

Lastly, at the time of writing, MockVM did not yet support the Koinos cryptographic functions. Those test cases are listed there but are unimplemented.

The tests can be executed by running `yarn test`. You will see a summary of the test cases as well as a coverage report.

```
â¯ yarn test
yarn run v1.22.19
$ koinos-sdk-as-cli run-tests
Running tests...
yarn asp --verbose --config as-pect.config.js
$ /home/michael/dev/todos/node_modules/.bin/asp --verbose --config as-pect.config.js
       ___   _____                       __
      /   | / ___/      ____  ___  _____/ /_
     / /| | \__ \______/ __ \/ _ \/ ___/ __/
    / ___ |___/ /_____/ /_/ /  __/ /__/ /_
   /_/  |_/____/     / .___/\___/\___/\__/
                    /_/

âš¡AS-pectâš¡ Test suite runner [6.2.4]

[Log] Loading asc compiler
Assemblyscript Folder:assemblyscript
[Log] Compiler loaded in 162.594ms.
[Log] Using configuration /home/michael/dev/todos/as-pect.config.js
[Log] Using VerboseReporter
[Log] Including files: assembly/__tests__/**/*.spec.ts
[Log] Running tests that match: (:?)
[Log] Running groups that match: (:?)
[Log] Effective command line args:
  [TestFile.ts] node_modules/@as-pect/assembly/assembly/index.ts --runtime incremental --debug --binaryFile output.wasm --explicitStart --use ASC_RTRACE=1 --exportTable --importMemory --transform /home/michael/dev/todos/node_modules/@as-covers/transform/lib/index.js,/home/michael/dev/todos/node_modules/@as-pect/core/lib/transform/index.js --lib node_modules/@as-covers/assembly/index.ts

[Describe]: todos

[Event] todos.todo_added_event / [ '1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe' ] / CgtUZXN0IGl0ZW0gMQ==
[Event] todos.todo_added_event / [ '1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe' ] / CgtUZXN0IGl0ZW0gMg==
 [Success]: âœ” should add todo items RTrace: +480
[Error] Error: authority is not set
[Contract Exit] account '1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe' authorization failed
 [Success]: âœ” should not add todo item without authorization RTrace: +161
 [Success]: âœ” should authorize
 [Success]: âœ” should not authorize

    [File]: assembly/__tests__/Todos.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: âœ” PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 4 pass,  0 fail, 4 total
    [Time]: 44.189ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: âœ” PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 4 pass, 0 fail, 4 total
    [Time]: 4342.112ms
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File              â”‚ Total â”‚ Block â”‚ Func  â”‚ Expr â”‚ Uncovered                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ assembly/Todos.ts â”‚ 44.4% â”‚ 40%   â”‚ 66.7% â”‚ 0%   â”‚ 51:78, 62:56, 66:45, 66:76, 51:3 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ total             â”‚ 44.4% â”‚ 40%   â”‚ 66.7% â”‚ 0%   â”‚                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Done in 4.56s.
```

### Deployment

Let's put this all together. We now have a smart contract that authorizes itself and emits events. Let's deploy it and test it out.

```
ðŸ”“ > upload contract.wasm todos.abi true false false
Contract uploaded with address 1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H
Transaction with ID 0x1220209060668195c7cd3778f77aca976d38eed186a21b1cebccf0140a1caf1f330d containing 1 operations submitted.
Mana cost: 1.56339119 (Disk: 30763, Network: 32434, Compute: 387331)

ðŸ”“ > register todos 1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H
Contract 'todos' at address 1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H registered
```

Once the contract has been uploaded we can register it in the CLI to interact with the contract.

```
 > todos.get_todos


ðŸ”“ > todos.add_todo "Finish todos workshop 4"
Calling todos.add_todo with arguments 'task: "Finish todos workshop 4"
'
Transaction with ID 0x122013d808dcdacae86bca9d8a0683a4c5ae463f542f41a1129951f6f8c7820ffba0 containing 1 operations submitted.
Mana cost: 0.0350406 (Disk: 54, Network: 278, Compute: 771777)

ðŸ”“ > todos.get_todos
value: "Finish todos workshop 4"
```

We can call the contract and add a todo item and get the item back. Create a new wallet to test the authorization (Don't forget to transfer a couple KOIN to the new address to pay the mana for the transaction).

```
ðŸ”“ > register_token tkoin 1FaSvLjQJsCJKq5ybmGsMMQs8RQYyVv8ju
Token 'tkoin' at address 1FaSvLjQJsCJKq5ybmGsMMQs8RQYyVv8ju registered

ðŸ”“ > tkoin.transfer 1PMnH7WQwFtrBZyKzdDRegzEnNbVehDeKd 1
Transferring 1 tKOIN to 1PMnH7WQwFtrBZyKzdDRegzEnNbVehDeKd
Transaction with ID 0x1220276195dc6ea3cc87f7b3b9cd77de7a522a2b25dc7e84ee14ecfbe1808f40197b containing 1 operations submitted.
Mana cost: 0.03858435 (Disk: 77, Network: 312, Compute: 829837)
```

_**Note:** Replace the transfer address with your address._

```
ðŸ”“ > open test.wallet test
Opened wallet: test.wallet

ðŸ”“ > address
Wallet address: 1PMnH7WQwFtrBZyKzdDRegzEnNbVehDeKd

ðŸ”“ > todos.add_todo "Test add todo from a different address"
cannot make call, account '1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H' authorization failed
```

Now open the wallet whose address was hardcoded into the contract. In this tutorial, that was `1NRz4i4UhVJ5MMeNwDTwTY95ZygtpuPwPU`.

```
ðŸ”“ > open user.wallet user
Opened wallet: user.wallet

ðŸ”“ > address
Wallet address: 1NRz4i4UhVJ5MMeNwDTwTY95ZygtpuPwPU

ðŸ”“ > todos.add_todo "Test add todo from a different address"
Calling todos.add_todo with arguments 'task: "Test add todo from a different address"
'
Transaction with ID 0x122013a96c9f0fbed4fc8728e322a471a4a93acdcef4686b7c4693424ac49e7ebd0c containing 1 operations submitted.
Mana cost: 0.0364933 (Disk: 75, Network: 293, Compute: 782851)
```

We just sent the transaction from a different address and the contract defined its own authorization!

Let's check the events in the API and verify they were generated correctly.

```bash
> curl -d '{"jsonrpc":"2.0", "method":"account_history.get_account_history", "params":{"address":"1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H", "limit":3, "ascending":false}, "id":0}' https://harbinger-api.koinos.io | jq
```

A lot of information is going to be returned. If you look in the transaction receipt, you will see events.

```json
"events": [
  {
    "sequence": 2,
    "source": "1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H",
    "name": "todos.todo_added_event",
    "data": "CiZUZXN0IGFkZCB0b2RvIGZyb20gYSBkaWZmZXJlbnQgYWRkcmVzcw==",
    "impacted": [
      "1MsphTEBkYPxdBYHexD1Xj1QiwCe3Qr17H"
    ]
  }
],
```

On https://protobuf-decoder.netlify.app/ you can input the base64 `data` field and it will decode it as a protobuf message with a single string field whose value is, "Test add todo from a different address" which is precisely what we expected to get back!

### Conclusion

In this tutorial we secured our smart contract by requiring an authority check, we overrode our own authority to allow two addresses to add todo items, emitted an event on successfully adding an event, tested our smart contract, and tested the behavior of our additions on the Harbinger testnet.

We welcome you to join the Koinos Discord and engage with our active developer community! https://discord.koinos.io
